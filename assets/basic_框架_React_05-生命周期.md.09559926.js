import{_ as s,o,c as n,V as a}from"./chunks/framework.f3592640.js";const C=JSON.parse('{"title":"生命周期","description":"","frontmatter":{},"headers":[],"relativePath":"basic/框架/React/05-生命周期.md","filePath":"basic/框架/React/05-生命周期.md"}'),p={name:"basic/框架/React/05-生命周期.md"},l=a(`<h1 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h1><h2 id="_1-简介" tabindex="-1">1.简介 <a class="header-anchor" href="#_1-简介" aria-label="Permalink to &quot;1.简介&quot;">​</a></h2><p>组件从创建到死亡，会经过一些特定的阶段</p><p>React 组件中包含一系列钩子函数{生命周期回调函数}，会在特定的时刻调用</p><p>我们在定义组件的时候，会在特定的声明周期回调函数中，做特定的工作</p><p>在 React 中为我们提供了一些生命周期钩子函数，让我们能在 React 执行的重要阶段，在钩子函数中做一些事情。那么在 React 的生命周期中，有哪些钩子函数呢，我们来总结一下</p><p><strong>react 生命周期(旧)</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#F78C6C;">1.</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">初始化阶段</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> 由ReactDOM</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">render</span><span style="color:#A6ACCD;">()触发</span><span style="color:#89DDFF;">---</span><span style="color:#A6ACCD;">初次渲染</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#F78C6C;">1.</span><span style="color:#A6ACCD;">	</span><span style="color:#82AAFF;">constructor</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#F78C6C;">2.</span><span style="color:#A6ACCD;">	</span><span style="color:#82AAFF;">componentWillMount</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#F78C6C;">3.</span><span style="color:#A6ACCD;">	</span><span style="color:#82AAFF;">render</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#F78C6C;">4.</span><span style="color:#A6ACCD;">	</span><span style="color:#82AAFF;">componentDidMount</span><span style="color:#A6ACCD;">() </span><span style="color:#89DDFF;">=====&gt;</span><span style="color:#A6ACCD;"> 常用</span></span>
<span class="line"><span style="color:#A6ACCD;">                        一般在这个钩子中做一些初始化的事，例如：开启定时器、发送网络请求、订阅消息</span></span>
<span class="line"><span style="color:#F78C6C;">2.</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">更新阶段</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> 由组件内部this</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setSate</span><span style="color:#A6ACCD;">()或父组件render触发</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#F78C6C;">1.</span><span style="color:#A6ACCD;">	</span><span style="color:#82AAFF;">shouldComponentUpdate</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#F78C6C;">2.</span><span style="color:#A6ACCD;">	</span><span style="color:#82AAFF;">componentWillUpdate</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#F78C6C;">3.</span><span style="color:#A6ACCD;">	</span><span style="color:#82AAFF;">render</span><span style="color:#A6ACCD;">() </span><span style="color:#89DDFF;">=====&gt;</span><span style="color:#A6ACCD;"> 必须使用的一个</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#F78C6C;">4.</span><span style="color:#A6ACCD;">	</span><span style="color:#82AAFF;">componentDidUpdate</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#F78C6C;">3.</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">卸载组件</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> 由ReactDOM</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">unmountComponentAtNode</span><span style="color:#A6ACCD;">()触发</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#F78C6C;">1.</span><span style="color:#A6ACCD;">	</span><span style="color:#82AAFF;">componentWillUnmount</span><span style="color:#A6ACCD;">()  </span><span style="color:#89DDFF;">=====&gt;</span><span style="color:#A6ACCD;"> 常用</span></span>
<span class="line"><span style="color:#A6ACCD;">                        一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息</span></span></code></pre></div><p>在最新的 react 版本中，有些生命周期钩子被抛弃了，具体函数如下：</p><ul><li><code>componentWillMount</code></li><li><code>componentWillReceiveProps</code></li><li><code>componentWillUpdate</code></li></ul><p>这些生命周期方法经常被误解和滥用；此外，我们预计，在异步渲染中，它们潜在的误用问题可能更大。我们将在即将发布的版本中为这些生命周期添加 “UNSAFE_” 前缀。（这里的 “unsafe” 不是指安全性，而是表示使用这些生命周期的代码在 React 的未来版本中更有可能出现 bug，尤其是在启用异步渲染之后。）</p><p>由此可见，新版本中并不推荐持有这三个函数，取而代之的是带有 UNSAFE* 前缀的三个函数，比如: UNSAFE* componentWillMount。即便如此，其实 React 官方还是不推荐大家去使用，在以后版本中有可能会去除这几个函数。</p><p><strong>react 生命周期(新)</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#F78C6C;">1.</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">初始化阶段</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> 由ReactDOM</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">render</span><span style="color:#A6ACCD;">()触发</span><span style="color:#89DDFF;">---</span><span style="color:#A6ACCD;">初次渲染</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#F78C6C;">1.</span><span style="color:#A6ACCD;">	</span><span style="color:#82AAFF;">constructor</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#F78C6C;">2.</span><span style="color:#A6ACCD;">	getDerivedStateFromProps</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#F78C6C;">3.</span><span style="color:#A6ACCD;">	</span><span style="color:#82AAFF;">render</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#F78C6C;">4.</span><span style="color:#A6ACCD;">	</span><span style="color:#82AAFF;">componentDidMount</span><span style="color:#A6ACCD;">() </span><span style="color:#89DDFF;">=====&gt;</span><span style="color:#A6ACCD;"> 常用</span></span>
<span class="line"><span style="color:#A6ACCD;">                	一般在这个钩子中做一些初始化的事，例如：开启定时器、发送网络请求、订阅消息</span></span>
<span class="line"><span style="color:#F78C6C;">2.</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">更新阶段</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> 由组件内部this</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setSate</span><span style="color:#A6ACCD;">()或父组件重新render触发</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#F78C6C;">1.</span><span style="color:#A6ACCD;">	getDerivedStateFromProps</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#F78C6C;">2.</span><span style="color:#A6ACCD;">	</span><span style="color:#82AAFF;">shouldComponentUpdate</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#F78C6C;">3.</span><span style="color:#A6ACCD;">	</span><span style="color:#82AAFF;">render</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#F78C6C;">4.</span><span style="color:#A6ACCD;">	getSnapshotBeforeUpdate</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#F78C6C;">5.</span><span style="color:#A6ACCD;">	</span><span style="color:#82AAFF;">componentDidUpdate</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#F78C6C;">3.</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">卸载组件</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> 由ReactDOM</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">unmountComponentAtNode</span><span style="color:#A6ACCD;">()触发</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#F78C6C;">1.</span><span style="color:#A6ACCD;">	</span><span style="color:#82AAFF;">componentWillUnmount</span><span style="color:#A6ACCD;">()  </span><span style="color:#89DDFF;">=====&gt;</span><span style="color:#A6ACCD;"> 常用</span></span>
<span class="line"><span style="color:#A6ACCD;">                	一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息</span></span></code></pre></div><h2 id="_2-初始化阶段" tabindex="-1">2.初始化阶段 <a class="header-anchor" href="#_2-初始化阶段" aria-label="Permalink to &quot;2.初始化阶段&quot;">​</a></h2><p><strong>在组件实例被创建并插入到 dom 中时，生命周期调用顺序如下</strong></p><p><strong>旧生命周期：</strong></p><ol><li><code>constructor（props）</code></li><li><code>componentWillMount()</code> （不建议）</li><li><code>render()</code></li><li><code>componentDidMount()</code></li></ol><p><strong>新生命周期：</strong></p><ol><li><code>constructor（props）</code></li><li><code>static getDerivedStateFromProps（props，state）</code>（替代了）<code>componentWillReceiveProps</code></li><li><code>render()</code></li><li><code>componentDidMount()</code></li></ol><h3 id="_2-1-constructor" tabindex="-1">2.1 constructor <a class="header-anchor" href="#_2-1-constructor" aria-label="Permalink to &quot;2.1 constructor&quot;">​</a></h3><p><strong>数据初始化。</strong>：接收 <code>props</code> 和 <code>context</code>，当想在函数内使用这两个参数需要在 <code>super</code> 传入参数，当使用 <code>constructor</code> 时必须使用 <code>super</code>，否则可能会有 <code>this</code> 的指向问题，如果不初始化 <code>state</code> 或者不进行方法绑定，则可以不为组件实现构造函数；</p><p>避免将 <code>props</code> 的值复制给 <code>state</code>！这是一个常见的错误：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">constructor</span><span style="color:#A6ACCD;">(props) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">super</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">props</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;"> </span><span style="color:#676E95;font-style:italic;">// 不要这样做</span></span>
<span class="line"><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">state</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> color</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">props</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">color</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>如此做毫无必要（可以直接使用 <code>this.props.color</code>），同时还产生了 bug（更新 <code>prop</code> 中的 color 时，并不会影响 <code>state</code>）。</p><p>现在我们通常不会使用 <code>constructor</code> 属性，而是改用类加箭头函数的方法，来替代 <code>constructor</code></p><p>例如，我们可以这样初始化 <code>state</code></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">state </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">count</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h3 id="_2-2-componentwillmount-即将废弃" tabindex="-1">2.2 componentWillMount（即将废弃） <a class="header-anchor" href="#_2-2-componentwillmount-即将废弃" aria-label="Permalink to &quot;2.2 componentWillMount（即将废弃）&quot;">​</a></h3><p><strong>该方法只在挂载的时候调用一次，表示组件将要被挂载，并且在 <code>render</code> 方法之前调用。</strong></p><blockquote><p>如果存在 <code>getDerivedStateFromProps</code> 和 <code>getSnapshotBeforeUpdate</code> 就不会执行生命周期<code>componentWillMount</code>。</p></blockquote><p>​ 在服务端渲染唯一会调用的函数，代表已经初始化数据但是没有渲染 dom，因此在此方法中同步调用 <code>setState()</code> 不会触发额外渲染。</p><p><strong>这个方法在 React 18 版本中将要被废弃，官方解释是在 React 异步机制下，如果滥用这个钩子可能会有 Bug</strong></p><h3 id="_2-3-static-getderivedstatefromprops-新钩子" tabindex="-1">2.3 static getDerivedStateFromProps（新钩子） <a class="header-anchor" href="#_2-3-static-getderivedstatefromprops-新钩子" aria-label="Permalink to &quot;2.3 static getDerivedStateFromProps（新钩子）&quot;">​</a></h3><p><strong>从 props 获取 state。</strong></p><p>替代了<code>componentWillReceiveProps</code>，此方法适用于<a href="https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#when-to-use-derived-state" target="_blank" rel="noreferrer">罕见的用例</a>，即 state 的值在任何时候都取决于 props。</p><p>这个是 React 新版本中新增的 2 个钩子之一，据说很少用。</p><ol><li><p>首先，该函数会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用；</p></li><li><p>该函数必须是静态的；</p></li><li><p>给组件传递的数据（props）以及组件状态（state），会作为参数到这个函数中；</p></li><li><p>该函数也必须有返回值，返回一个 Null 或者 state 对象。因为初始化和后续更新都会执行这个方法，因此在这个方法返回 state 对象，就相当于将原来的 state 进行了覆盖，所以倒是修改状态不起作用。</p></li></ol><blockquote><p>注意：<code>state</code> 的值在任何时候都取决于传入的 <code>props</code> ，不会再改变</p></blockquote><p>如下</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">static </span><span style="color:#82AAFF;">getDerivedStateFromProps</span><span style="color:#A6ACCD;">(props</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> state) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">ReactDOM</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">render</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Count</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">count</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">109</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">/&gt;,</span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">querySelector</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">.test</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">))</span></span></code></pre></div><p><code>count</code> 的值不会改变，一直是 109</p><blockquote><p><a href="https://www.jianshu.com/p/b331d0e4b398" target="_blank" rel="noreferrer">React 的生命周期 - 简书</a></p><p>老版本中的 <code>componentWillReceiveProps()</code>方法判断前后两个 <code>props</code> 是否相同，如果不同再将新的 <code>props</code> 更新到相应的 <code>state</code> 上去。这样做一来会破坏 <code>state</code> 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。</p><p>这两者最大的不同就是: 在 <code>componentWillReceiveProps</code> 中，我们一般会做以下两件事，一是根据 <code>props</code> 来更新 <code>state</code>，二是触发一些回调，如动画或页面跳转等。</p><ol><li>在老版本的 React 中，这两件事我们都需要在 <code>componentWillReceiveProps</code> 中去做。</li><li>而在新版本中，官方将更新 <code>state</code> 与触发回调重新分配到了 <code>getDerivedStateFromProps</code> 与 <code>componentDidUpdate</code> 中，使得组件整体的更新逻辑更为清晰。而且在 <code>getDerivedStateFromProps</code> 中还禁止了组件去访问 <code>this.props</code>，强制让开发者去比较 <code>nextProps</code> 与 <code>prevState</code> 中的值，以确保当开发者用到 <code>getDerivedStateFromProps</code> 这个生命周期函数时，就是在根据当前的 <code>props</code> 来更新组件的 <code>state</code>，而不是去做其他一些让组件自身状态变得更加不可预测的事情。</li></ol></blockquote><h3 id="_2-4-render" tabindex="-1">2.4 render <a class="header-anchor" href="#_2-4-render" aria-label="Permalink to &quot;2.4 render&quot;">​</a></h3><p><strong>class 组件中唯一必须实现的方法。</strong></p><blockquote><p>render 函数会插入 jsx 生成的 dom 结构，react 会生成一份虚拟 dom 树，在每一次组件更新时，在此 react 会通过其 diff 算法比较更新前后的新旧 DOM 树，比较以后，找到最小的有差异的 DOM 节点，并重新渲染。</p></blockquote><blockquote><p>注意：避免在 <code>render</code> 中使用 <code>setState</code> ，否则会死循环</p></blockquote><p>当 render 被调用时，他会检查 this.props.和 this.state 的变化并返回以下类型之一：</p><ol><li>通过 jsx 创建的 react 元素</li><li>数组或者 fragments：使得 render 可以返回多个元素</li><li>Portals:可以渲染子节点到不同的 dom 树上</li><li>字符串或数值类型：他们在 dom 中会被渲染为文本节点</li><li>布尔类型或者 null：什么都不渲染</li></ol><h3 id="_2-5-componentdidmount" tabindex="-1">2.5 componentDidMount <a class="header-anchor" href="#_2-5-componentdidmount" aria-label="Permalink to &quot;2.5 componentDidMount&quot;">​</a></h3><p><strong>在组件挂在后（插入到 dom 树中）后立即调用</strong></p><p><code>componentDidMount</code> 的执行意味着初始化挂载操作已经基本完成，它主要用于组件挂载完成后做某些操作</p><p>这个挂载完成指的是：组件插入 DOM tree</p><p>​ 可以在这里调用 Ajax 请求，返回的数据可以通过 setState 使组件重新渲染，或者添加订阅，但是要在 <code>conponentWillUnmount</code> 中取消订阅</p><h3 id="_2-6-初始化阶段总结" tabindex="-1">2.6 初始化阶段总结 <a class="header-anchor" href="#_2-6-初始化阶段总结" aria-label="Permalink to &quot;2.6 初始化阶段总结&quot;">​</a></h3><p>执行顺序 <code>constructor</code> -&gt; <code>getDerivedStateFromProps</code> 或者 <code>componentWillMount</code> -&gt; <code>render</code> -&gt; <code>componentDidMount</code></p><h2 id="_3-更新阶段" tabindex="-1">3.更新阶段 <a class="header-anchor" href="#_3-更新阶段" aria-label="Permalink to &quot;3.更新阶段&quot;">​</a></h2><p><strong>当组件的 props 或 state 发生变化时会触发更新。</strong></p><p><strong>旧生命周期：</strong></p><ol><li><p><code>componentWillReceiveProps(nextProps)</code> （不建议）</p></li><li><p><code>shouldComponentUpdate(nextProps,nextState)</code></p></li><li><p><code>componetnWillUpdate(nextProps,nextState)</code> （不建议）</p></li><li><p><code>render()</code></p></li><li><p><code>componentDidUpdate(prevProps,precState,snapshot)</code></p></li></ol><p><strong>新生命周期：</strong></p><ol><li><code>static getDerivedStateFromProps(nextProps, prevState)</code></li><li><code>shouldComponentUpdate(nextProps,nextState)</code></li><li><code>render()</code></li><li><code>getSnapshotBeforeUpdate(prevProps,prevState)</code></li><li><code>componentDidUpdate(prevProps,precState,snapshot)</code></li></ol><h3 id="_3-1-componentwillreceiveprops-即将废弃" tabindex="-1">3.1 componentWillReceiveProps (即将废弃) <a class="header-anchor" href="#_3-1-componentwillreceiveprops-即将废弃" aria-label="Permalink to &quot;3.1 componentWillReceiveProps (即将废弃)&quot;">​</a></h3><p><strong>在已挂载的组件接收新的 props 之前调用。</strong></p><p>通过对比 nextProps 和 this.props，将 nextProps 的 state 为当前组件的 state，从而重新渲染组件，可以在此方法中使用 this.setState 改变 state。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">componentWillReceiveProps</span><span style="color:#A6ACCD;"> (nextProps) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">nextProps</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">openNotice</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!==</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">props</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">openNotice</span><span style="color:#89DDFF;">&amp;&amp;this.</span><span style="color:#82AAFF;">setState</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        openNotice</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;">nextProps</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">openNotice</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">，</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">openNotice</span><span style="color:#F07178;">:</span><span style="color:#A6ACCD;">nextProps</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">//将state更新为nextProps,在setState的第二个参数（回调）可以打         印出新的state</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><blockquote><p>请注意，如果父组件导致组件重新渲染，即使 <code>props</code> 没有更改，也会调用此方法。如果只想处理更改，请确保进行当前值与变更值的比较。</p><p>React 不会针对初始 <code>props</code> 调用 <code>UNSAFE_componentWillReceiveProps()</code>。组件只会在组件的 <code>props</code> 更新时调用此方法。调用 <code>this.setState()</code> 通常不会触发该生命周期。</p></blockquote><h3 id="_3-2-shouldcomponentupdate" tabindex="-1">3.2 shouldComponentUpdate <a class="header-anchor" href="#_3-2-shouldcomponentupdate" aria-label="Permalink to &quot;3.2 shouldComponentUpdate&quot;">​</a></h3><p>在渲染之前被调用，默认返回为 <code>true</code>。</p><p>​ 返回值是判断组件的输出是否受当前 <code>state</code> 或 <code>props</code> 更改的影响，默认每次 state 发生变化都重新渲染，首次渲染或使用 <code>forceUpdate</code>（使用<code>this.forceUpdate()</code>）时不被调用。</p><blockquote><p>他主要用于性能优化，会对 <code>props</code> 和 <code>state</code> 进行浅层比较，并减少了跳过必要更新的可能性。不建议深层比较，会影响性能。如果返回 <code>false</code>，则不会调用 <code>componentWillUpdate</code>、<code>render</code> 和 <code>componentDidUpdate</code>。</p></blockquote><ul><li>唯一用于控制组件重新渲染的生命周期，由于在 react 中，<code>setState</code> <code>以后，state</code> 发生变化，组件会进入重新渲染的流程，在这里 <code>return false</code> 可以阻止组件的更新，但是不建议，建议使用 <code>PureComponent</code></li><li>因为 react 父组件的重新渲染会导致其所有子组件的重新渲染，这个时候其实我们是不需要所有子组件都跟着重新渲染的，因此需要在子组件的该生命周期中做判断</li></ul><h3 id="_3-3-componentwillupdate-即将废弃" tabindex="-1">3.3 componentWillUpdate (即将废弃) <a class="header-anchor" href="#_3-3-componentwillupdate-即将废弃" aria-label="Permalink to &quot;3.3 componentWillUpdate (即将废弃)&quot;">​</a></h3><p><strong>当组件接收到新的 <code>props</code> 和 <code>state</code> 会在渲染前调用，初始渲染不会调用该方法。</strong></p><p>​ <code>shouldComponentUpdate</code> 返回 <code>true</code> 以后，组件进入重新渲染的流程，进入 <code>componentWillUpdate</code>，不能在这使用 <code>setState</code>，在函数返回之前不能执行任何其他更新组件的操作</p><blockquote><p>此方法可以替换为 <code>componentDidUpdate()</code>。如果你在此方法中读取 DOM 信息（例如，为了保存滚动位置），则可以将此逻辑移至 <code>getSnapshotBeforeUpdate()</code> 中。</p></blockquote><h3 id="_3-4-getsnapshotbeforeupdate-新钩子" tabindex="-1">3.4 getSnapshotBeforeUpdate（新钩子） <a class="header-anchor" href="#_3-4-getsnapshotbeforeupdate-新钩子" aria-label="Permalink to &quot;3.4 getSnapshotBeforeUpdate（新钩子）&quot;">​</a></h3><p><strong>在最近一次的渲染输出之前被提交之前调用，也就是即将挂载时调用，替换 <code>componetnWillUpdate。</code></strong></p><p>相当于淘宝购物的快照，会保留下单前的商品内容，在 React 中就相当于是 即将更新前的状态</p><p>它可以使组件在 DOM 真正更新之前捕获一些信息（例如滚动位置），此生命周期返回的任何值都会作为参数传递给 <code>componentDidUpdate()</code>。如不需要传递任何值，那么请返回 null</p><blockquote><p>和 <code>componentWillUpdate</code> 的区别</p><ul><li>在 React 开启异步渲染模式后，在 <code>render</code> 阶段读取到的 DOM 元素状态并不总是和 <code>commit</code> 阶段相同，这就导致在 <code>componentDidUpdate</code> 中使用 <code>componentWillUpdate</code> 中读取到的 DOM 元素状态是不安全的，因为这时的值很有可能已经失效了。</li><li><code>getSnapshotBeforeUpdate</code> 会在最终的 <code>render</code> 之前被调用，也就是说 <code>getSnapshotBeforeUpdate</code> 中读取到的 DOM 元素状态是可以保证与 <code>componentDidUpdate</code> 中一致的。</li></ul></blockquote><h3 id="_3-5-componentdidupdate" tabindex="-1">3.5 componentDidUpdate <a class="header-anchor" href="#_3-5-componentdidupdate" aria-label="Permalink to &quot;3.5 componentDidUpdate&quot;">​</a></h3><p><strong>组件在更新完毕后会立即被调用，首次渲染不会调用</strong></p><p>可以在该方法调用 <code>setState</code>，但是要包含在条件语句中，否则一直更新会造成死循环。</p><p>当组件更新后，可以在此处对 DOM 进行操作。如果对更新前后的 <code>props</code> 进行了比较，可以进行网络请求。（当 <code>props</code> 未发生变化时，则不会执行网络请求）。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">componentDidUpdate</span><span style="color:#A6ACCD;">(prevProps</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">prevState</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">snapshotValue) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 典型用法（不要忘记比较 props）：</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">props</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">userID</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!==</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">prevProps</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">userID</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">fetchData</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">props</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">userID</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><blockquote><p>如果组件实现了 <code>getSnapshotBeforeUpdate()</code> 生命周期（不常用），则它的返回值将作为 <code>componentDidUpdate()</code> 的第三个参数 <code>“snapshotValue”</code> 参数传递。否则此参数将为 <code>undefined</code>。如果返回 <code>false</code> 就不会调用这个函数。</p></blockquote><h3 id="_3-6-getsnapshotbeforeupdate-使用场景" tabindex="-1">3.6 getSnapshotBeforeUpdate 使用场景 <a class="header-anchor" href="#_3-6-getsnapshotbeforeupdate-使用场景" aria-label="Permalink to &quot;3.6 getSnapshotBeforeUpdate 使用场景&quot;">​</a></h3><p>在一个区域内，定时的输出以行话，如果内容大小超过了区域大小，就出现滚动条，但是内容不进行移动</p><p>1.首先我们先实现定时输出内容</p><p>我们可以使用 <code>state</code> 状态，改变新闻后面的值，但是为了同时显示这些内容，我们应该为 <code>state</code> 的属性定义一个数组。并在创建组件之后开启一个定时器，不断的进行更新 <code>state</code>。更新渲染组件</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">New</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">React</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">Component</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">state</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">num</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> [] </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">//在组件创建之后,开启一个定时任务</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">componentDidMount</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">setInterval</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">num</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">state</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">news</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">num</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">length</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">setState</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> num</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> [</span><span style="color:#A6ACCD;">news</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;">num</span><span style="color:#F07178;">] </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">2000</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">render</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> (</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">ref</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">list</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">className</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">list</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">{this.</span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">num</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">map</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">n</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">index</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">          </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> (</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">className</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">news</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">index</span><span style="color:#89DDFF;">}&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">              新闻</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">n</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">          )</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">    )</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">ReactDOM</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">render</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">New</span><span style="color:#89DDFF;"> /&gt;,</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getElementById</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">div</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">))</span></span></code></pre></div><p>2.接下来就是控制滚动条了</p><p>我们在组件渲染到 DOM 之前获取组件的高度，然后用组件渲染之后的高度减去之前的高度就是一条新的内容的高度，这样在不断的累加到滚动条位置上。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">getSnapshotBeforeUpdate</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">refs</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">list</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">scrollHeight</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">componentDidUpdate</span><span style="color:#A6ACCD;">(preProps</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">preState</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">height)</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">refs</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">list</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">scrollTop</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+=</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">refs</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">list</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">scrollHeight</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">height</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>这样就实现了这个功能。</p><h2 id="_4-卸载组件" tabindex="-1">4.卸载组件 <a class="header-anchor" href="#_4-卸载组件" aria-label="Permalink to &quot;4.卸载组件&quot;">​</a></h2><p><strong>当组件从 DOM 中移除时会调用如下方法</strong></p><h3 id="_4-1-componentwillunmount" tabindex="-1">4.1 componentWillUnmount <a class="header-anchor" href="#_4-1-componentwillunmount" aria-label="Permalink to &quot;4.1 componentWillUnmount&quot;">​</a></h3><p><strong>在组件卸载和销毁之前调用</strong></p><p>使用这样的方式去卸载：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">ReactDOM.unmountComponentAtNode(document.getElementById(&#39;test&#39;))</span></span></code></pre></div><p>在这执行必要的清理操作，例如，清除 <code>timer（setTimeout,setInterval）</code>，取消网络请求，或者取消在 <code>componentDidMount</code> 的订阅，移除所有监听</p><p>有时候我们会碰到这个 warning:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Can only update a mounted or mounting component</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;"> This usually means you called </span><span style="color:#82AAFF;">setState</span><span style="color:#A6ACCD;">() on an unmounted component</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;"> This is a   no</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">op</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;"> Please check the code for the </span><span style="color:#89DDFF;">undefined</span><span style="color:#A6ACCD;"> component</span><span style="color:#89DDFF;">.</span></span></code></pre></div><p>原因：因为你在组件中的 ajax 请求返回 <code>setState</code>, 而你组件销毁的时候，请求还未完成，因此会报 warning</p><p>解决方法：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">componentDidMount</span><span style="color:#A6ACCD;">() </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">isMount</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">axios</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">post</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">res</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">isMount</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">setState</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">{</span><span style="color:#F07178;">   </span><span style="color:#676E95;font-style:italic;">// 增加条件ismount为true时</span></span>
<span class="line"><span style="color:#F07178;">      aaa</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;">res</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#82AAFF;">componentWillUnmount</span><span style="color:#A6ACCD;">() </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">isMount</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">false</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p><code>componentWillUnmount()</code> 中不应调用 <code>setState()</code>，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。</p>`,109),e=[l];function t(c,r,F,D,y,d){return o(),n("div",null,e)}const A=s(p,[["render",t]]);export{C as __pageData,A as default};
