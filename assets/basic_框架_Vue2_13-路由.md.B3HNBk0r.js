import{_ as s,c as e,J as i,a4 as t,o as l,aE as r,aF as o,aG as p,aH as h,aI as n,aJ as d,aK as c,aL as u,aM as g,aN as k,aO as m,aP as _,E as b}from"./chunks/framework.C8gDNRqg.js";const A=JSON.parse('{"title":"13-Vue-router路由","description":"","frontmatter":{"title":"13-Vue-router路由","publish":true},"headers":[],"relativePath":"basic/框架/Vue2/13-路由.md","filePath":"basic/框架/Vue2/13-路由.md"}'),v={name:"basic/框架/Vue2/13-路由.md"},E=t('<h2 id="什么是路由" tabindex="-1">什么是路由 <a class="header-anchor" href="#什么是路由" aria-label="Permalink to &quot;什么是路由&quot;">​</a></h2><h3 id="后端路由" tabindex="-1">后端路由 <a class="header-anchor" href="#后端路由" aria-label="Permalink to &quot;后端路由&quot;">​</a></h3><p>对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源。</p><p>当前端输入url请求资源时，服务器会监听到是什么url地址，那后端会返回什么样的资源呢？后端这个处理的过程就是通过<strong>路由</strong>来<strong>分发</strong>的。</p><p><strong>总结</strong>：后端路由，就是把所有url地址都对应到服务器的资源，这个<strong>对应关系</strong>就是路由。</p><h3 id="前端路由" tabindex="-1">前端路由 <a class="header-anchor" href="#前端路由" aria-label="Permalink to &quot;前端路由&quot;">​</a></h3><p>对于单页面应用程序来说，主要通过URL中的<code>hash</code>（url地址中的#号）来实现不同页面之间的切换。</p><p>同时，hash有一个特点：HTTP请求中不会包含hash相关的内容。所以，单页面程序中的页面跳转主要用hash实现。</p><p><img src="'+r+'" alt=""></p><p><strong>总结</strong>：在<strong>单页应用</strong>程序中，这种通过<code>hash</code>改变来<strong>切换页面</strong>的方式，称作前端路由（区别于后端路由）。</p><h2 id="安装vue-router的两种方式" tabindex="-1">安装Vue-router的两种方式 <a class="header-anchor" href="#安装vue-router的两种方式" aria-label="Permalink to &quot;安装Vue-router的两种方式&quot;">​</a></h2><ul><li>官方文档：<a href="https://router.vuejs.org/zh/" target="_blank" rel="noreferrer">https://router.vuejs.org/zh/</a></li></ul><p><strong>方式一</strong>：直接下载文件</p><p>下载网址：<a href="https://unpkg.com/vue-router/dist/vue-router.js" target="_blank" rel="noreferrer">https://unpkg.com/vue-router/dist/vue-router.js</a></p><p>下载之后，放进项目工程，然后我们在引入<code>vue.js</code>之后，再引入<code>vue-router.js</code>即可：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;vue2.5.16.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;vue-router3.0.1.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>然后，我们就可以在 window全局对象中使用 VueRouter这个对象。具体解释可以看接下来的代码中的注释。</p><p>注意，只要我们导入了 vue-router.js 这个包，在浏览器中打开网页时，url后面就会显示<code>#</code>这个符号。</p><h2 id="安装以后-我们如何在vue2项目中使用路由呢" tabindex="-1">安装以后，我们如何在Vue2项目中使用路由呢？ <a class="header-anchor" href="#安装以后-我们如何在vue2项目中使用路由呢" aria-label="Permalink to &quot;安装以后，我们如何在Vue2项目中使用路由呢？&quot;">​</a></h2><h3 id="_1-创建路由模块-新建src-router-index-js文件" tabindex="-1">1. 创建路由模块，新建<code>src -&gt; router -&gt; index.js</code>文件 <a class="header-anchor" href="#_1-创建路由模块-新建src-router-index-js文件" aria-label="Permalink to &quot;1. 创建路由模块，新建`src -&gt; router -&gt; index.js`文件&quot;">​</a></h3><p><img src="'+o+'" alt=""></p><h3 id="_2-在main-js中进行挂载" tabindex="-1">2. 在main.js中进行挂载 <a class="header-anchor" href="#_2-在main-js中进行挂载" aria-label="Permalink to &quot;2. 在main.js中进行挂载&quot;">​</a></h3><p><img src="'+p+'" alt=""></p><h3 id="_3-在模板中添加路由占位符-router-view" tabindex="-1">3. 在模板中添加路由占位符 <code>&lt;router-view&gt;</code> <a class="header-anchor" href="#_3-在模板中添加路由占位符-router-view" aria-label="Permalink to &quot;3. 在模板中添加路由占位符 `&lt;router-view&gt;`&quot;">​</a></h3><p><img src="'+h+'" alt=""></p><h3 id="_4-定义路由规则-在路由模块-路由实例对象中" tabindex="-1">4. 定义路由规则（在路由模块 -&gt; 路由实例对象中） <a class="header-anchor" href="#_4-定义路由规则-在路由模块-路由实例对象中" aria-label="Permalink to &quot;4. 定义路由规则（在路由模块 -&gt; 路由实例对象中）&quot;">​</a></h3><p><img src="'+n+'" alt=""></p><h3 id="_5-设置字段" tabindex="-1">5. 设置字段 <a class="header-anchor" href="#_5-设置字段" aria-label="Permalink to &quot;5. 设置字段&quot;">​</a></h3><ul><li><p>path：表示路由跳转的地址</p><ul><li><p>路由传参</p><ul><li><p>接收方：如下图所示，在基础路径/search后面加上/:参数名表示search这个路由组件接收的参数keyword，若后面再加个问号，就表示params参数可以传也可以不传（不必须）。 <img src="'+d+'" alt=""></p></li><li><p>传递方：在调用路由的组件内定义如下method <img src="'+c+'" alt=""></p></li></ul></li><li><p>component：路由跳转到哪个组件</p></li><li><p>name：路由名</p></li><li><p>meta：路由元信息，可以设置一些用于判断v-if或v-show的属性 <img src="'+u+'" alt=""></p></li><li><p>props：传参用</p></li></ul></li></ul><h3 id="_6-利用链接-router-link-替代原生a标签" tabindex="-1">6. 利用链接 <code>&lt;router-link&gt;</code> 替代原生a标签 <a class="header-anchor" href="#_6-利用链接-router-link-替代原生a标签" aria-label="Permalink to &quot;6. 利用链接 `&lt;router-link&gt;`  替代原生a标签&quot;">​</a></h3><p><img src="'+g+'" alt=""></p><h3 id="_7-嵌套路由" tabindex="-1">7. 嵌套路由 <a class="header-anchor" href="#_7-嵌套路由" aria-label="Permalink to &quot;7. 嵌套路由&quot;">​</a></h3><ul><li><p>定义页面元素： <img src="'+k+'" alt=""></p></li><li><p>声明路由规则：（注意hash地址不加“/”） <img src="'+m+`" alt=""></p></li><li><p>默认子路由：在children里path为空的路由称为默认子路由，会自动redirect。</p></li></ul><h3 id="_8-动态路由匹配" tabindex="-1">8. 动态路由匹配 <a class="header-anchor" href="#_8-动态路由匹配" aria-label="Permalink to &quot;8. 动态路由匹配&quot;">​</a></h3><blockquote><p>原理：使用嵌套路由时，父路由路径都一样，而子路由很多，写代码时复用性不高。此时，可以将路径一致的地方作为固定参数，将不一样的子路由路径设置为动态参数 id。</p></blockquote><p>那么具体怎么写呢？</p><ol><li><p>路由规则</p><ul><li>传统写法</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>{ &lt;path: &#39;.movie/:mid&#39;, component: Movie };</span></span></code></pre></div><ul><li>props传参（传给params而非query）</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>{ &lt;path: &#39;.movie/:mid&#39;, component: Movie, props: true };</span></span></code></pre></div></li><li><p>添加至模板中</p><ul><li>传统写法：<code>$route.params.参数名</code></li></ul><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Movie组件 --- {{$route.params.mid}} &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><ul><li>props传参</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>props: [&#39;mid&#39;], // 写在export default中</span></span>
<span class="line"><span>&lt;h3&gt;Movie组件 --- {{mid}} &lt;/h3&gt; // 写在模板中</span></span></code></pre></div></li></ol><p><strong>拓展</strong>：</p><ul><li>路由路径中，/后面的叫路径参数，用 $route.params.参数名 来获取。</li><li>?后面的叫查询参数，用 $route.query.参数名 来获取。</li></ul><h3 id="_9-编程式导航" tabindex="-1">9. 编程式导航 <a class="header-anchor" href="#_9-编程式导航" aria-label="Permalink to &quot;9. 编程式导航&quot;">​</a></h3><ol><li><code>this.$route.push(&#39;hash地址&#39;) </code>： 跳转到指定hash地址，并增加一条浏览历史。</li><li><code>this.$route.replace(&#39;hash地址&#39;) </code>：跳转到指定hash地址，并替换掉当前浏览历史。</li><li><code>this.$route.go(num)</code>：可以在浏览历史中前进或后退。简写如下： <ul><li><code>$route.back()</code>：后退</li><li><code>$route.forward()</code>：前进</li></ul></li></ol><h3 id="_10-导航守卫" tabindex="-1">10. 导航守卫 <a class="header-anchor" href="#_10-导航守卫" aria-label="Permalink to &quot;10. 导航守卫&quot;">​</a></h3><ol><li><p>全局前置守卫：一旦有路由跳转就会触发，守卫会避免一些错误。下图三个参数分别表示跳转后路径、跳转前路径和放行函数。 <img src="`+_+'" alt=""></p></li><li><p><code>next</code>函数的3种调用方式</p><ul><li>直接放行：<code>next()</code> 如上图所示。</li><li>强制跳转到登录页：<code>next(&#39;/login&#39;)</code></li><li>不允许跳转到后台主页：<code>next(false)</code></li></ul></li></ol>',43);function q(y,f,x,P,j,C){const a=b("ArticleTopAd");return l(),e("div",null,[i(a),E])}const $=s(v,[["render",q]]);export{A as __pageData,$ as default};
