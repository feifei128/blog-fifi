import{_ as s,c as i,o as a,a4 as t,b1 as n,b2 as h}from"./chunks/framework.C8gDNRqg.js";const u=JSON.parse('{"title":"构造函数和原型","description":"","frontmatter":{},"headers":[],"relativePath":"basic/进阶/JS高级/03-构造函数和原型.md","filePath":"basic/进阶/JS高级/03-构造函数和原型.md"}'),l={name:"basic/进阶/JS高级/03-构造函数和原型.md"},p=t(`<h1 id="构造函数和原型" tabindex="-1">构造函数和原型 <a class="header-anchor" href="#构造函数和原型" aria-label="Permalink to &quot;构造函数和原型&quot;">​</a></h1><h2 id="_1-原型对象-prototype" tabindex="-1">1. 原型对象 prototype <a class="header-anchor" href="#_1-原型对象-prototype" aria-label="Permalink to &quot;1. 原型对象 prototype&quot;">​</a></h2><h3 id="意义" tabindex="-1">意义 <a class="header-anchor" href="#意义" aria-label="Permalink to &quot;意义&quot;">​</a></h3><p>构造方法内存占用量非常大，每新建一个实例对象都要开辟一块新的内存空间。而构造方法有一个属性 prototype，该属性是一个对象，可用于存放共享方法，称为原型对象。</p><h3 id="如何使用呢" tabindex="-1">如何使用呢？ <a class="header-anchor" href="#如何使用呢" aria-label="Permalink to &quot;如何使用呢？&quot;">​</a></h3><ul><li>方法 1：</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Star</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  constructor: Star,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  sing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;我会唱歌&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  movie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    console</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">我会演电影</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&#39;);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>由于对 prototype 重新赋值，原来的默认属性被覆盖没了，所以此时需要手动指回 constructor 属性。</p><ul><li>方法 2：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>构造方法名.prototype.方法名 = function(){}    // 此时表示追加，不覆盖。</span></span></code></pre></div><p>** 注：一般情况下，公共属性定义在构造函数里，公共方法定义在原型对象里</p><h2 id="_2-对象原型-proto" tabindex="-1">2. 对象原型 （<code>__proto__</code>） <a class="header-anchor" href="#_2-对象原型-proto" aria-label="Permalink to &quot;2. 对象原型 （\`__proto__\`）&quot;">​</a></h2><h3 id="意义-1" tabindex="-1">意义 <a class="header-anchor" href="#意义-1" aria-label="Permalink to &quot;意义&quot;">​</a></h3><p>每个对象都有一个属性<code>__proto__</code>，指向构造函数的 <code>prototype</code> 原型对象。对象之所以可以使用构造函数的原型对象里的方法，就是因为<code>__proto__</code>。</p><p>** 注意：不能直接使用或赋值。</p><h2 id="_3-原型-constructor" tabindex="-1">3. 原型 （<code>constructor</code>） <a class="header-anchor" href="#_3-原型-constructor" aria-label="Permalink to &quot;3. 原型 （\`constructor\`）&quot;">​</a></h2><h3 id="意义-2" tabindex="-1">意义 <a class="header-anchor" href="#意义-2" aria-label="Permalink to &quot;意义&quot;">​</a></h3><p>对象原型 <code>__proto__</code> 和原型对象 <code>prototype</code> 都有一个属性 <code>constructor</code>，指回构造函数本身，记录当前对象引用于哪个构造函数。</p><h3 id="如何使用呢-1" tabindex="-1">如何使用呢？ <a class="header-anchor" href="#如何使用呢-1" aria-label="Permalink to &quot;如何使用呢？&quot;">​</a></h3><p>重新指回构造方法。</p><h2 id="_4-构造函数、实例对象、原型对象三者之间的关系" tabindex="-1">4. 构造函数、实例对象、原型对象三者之间的关系 <a class="header-anchor" href="#_4-构造函数、实例对象、原型对象三者之间的关系" aria-label="Permalink to &quot;4. 构造函数、实例对象、原型对象三者之间的关系&quot;">​</a></h2><p><img src="`+n+'" alt="avatar"></p><h2 id="_5-原型链" tabindex="-1">5. 原型链 <a class="header-anchor" href="#_5-原型链" aria-label="Permalink to &quot;5. 原型链&quot;">​</a></h2><p>原型对象 prototype 里也有一个 <code>__proto__</code> 对象原型，它指向 <code>Object.prototype</code>，这个原型对象包含 js 的所有内置对象方法。</p><p><img src="'+h+`" alt="avatar"></p><p>成员查找规则：如上图所示，由下向上，就近原则。</p><h2 id="_6-扩展内置对象方法" tabindex="-1">6. 扩展内置对象方法 <a class="header-anchor" href="#_6-扩展内置对象方法" aria-label="Permalink to &quot;6. 扩展内置对象方法&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Array</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">prototype.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    var</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> sum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">var</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">++){</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">        sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> +</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    return</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">var</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> arr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.log(arr.sum());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h2 id="_7-call-方法" tabindex="-1">7. call 方法 <a class="header-anchor" href="#_7-call-方法" aria-label="Permalink to &quot;7. call 方法&quot;">​</a></h2><ul><li>用于调用函数：</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fun.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//只能调用 fun 的构造方法</span></span></code></pre></div><ul><li>用于修改某函数的 this 指向：</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fun.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(对象名, 参数列表) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//将 fun 的 this 指向传入的第一个参数，并且可以向 fun 传入形参。</span></span></code></pre></div><h2 id="_8-利用原型对象继承方法-上一节笔记已详述" tabindex="-1">8. 利用原型对象继承方法：（上一节笔记已详述） <a class="header-anchor" href="#_8-利用原型对象继承方法-上一节笔记已详述" aria-label="Permalink to &quot;8. 利用原型对象继承方法：（上一节笔记已详述）&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>构造方法.prototype = new Father();</span></span>
<span class="line"><span>构造方法.prototype.constructor = 构造方法名;</span></span></code></pre></div>`,35),e=[p];function k(r,o,d,E,c,g){return a(),i("div",null,e)}const F=s(l,[["render",k]]);export{u as __pageData,F as default};
