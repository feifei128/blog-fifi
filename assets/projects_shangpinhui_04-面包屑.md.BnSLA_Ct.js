import{_ as a,c as i,o as e,a4 as p,bT as l,bU as r,bV as t,bW as s,bX as c,bY as o,bZ as _,b_ as m,b$ as n,c0 as h,c1 as g,c2 as u,c3 as d,c4 as b,c5 as S,c6 as f,c7 as q,c8 as x,c9 as P,ca as k,cb as T}from"./chunks/framework.C8gDNRqg.js";const J=JSON.parse('{"title":"面包屑","description":"","frontmatter":{},"headers":[],"relativePath":"projects/shangpinhui/04-面包屑.md","filePath":"projects/shangpinhui/04-面包屑.md"}'),j={name:"projects/shangpinhui/04-面包屑.md"},v=p('<h1 id="面包屑" tabindex="-1">面包屑 <a class="header-anchor" href="#面包屑" aria-label="Permalink to &quot;面包屑&quot;">​</a></h1><h2 id="_1-搜索结果数据渲染" tabindex="-1">1. 搜索结果数据渲染 <a class="header-anchor" href="#_1-搜索结果数据渲染" aria-label="Permalink to &quot;1. 搜索结果数据渲染&quot;">​</a></h2><h3 id="_1-1-vuex-仓库的-getters-属性" tabindex="-1">1.1 vuex 仓库的 getters 属性 <a class="header-anchor" href="#_1-1-vuex-仓库的-getters-属性" aria-label="Permalink to &quot;1.1 vuex 仓库的 getters 属性&quot;">​</a></h3><ul><li><p>概念：计算属性，为了简化仓库数据而生，当假 json 数据格式复杂时使用。</p></li><li><p>Search 小仓库 派发商品信息：</p><p><img src="'+l+'" alt="image.png"></p></li><li><p>Search 组件中请求数据</p><p><img src="'+r+'" alt="image.png"></p></li></ul><h3 id="_1-2-根据用户点击的选项卡或搜索词不同-返回不同的搜索结果。" tabindex="-1">1.2 根据用户点击的选项卡或搜索词不同，返回不同的搜索结果。 <a class="header-anchor" href="#_1-2-根据用户点击的选项卡或搜索词不同-返回不同的搜索结果。" aria-label="Permalink to &quot;1.2 根据用户点击的选项卡或搜索词不同，返回不同的搜索结果。&quot;">​</a></h3><ul><li><p>步骤一：整合参数，然后在派发数据时传递此参数。</p><p><img src="'+t+'" alt="image.png"></p><p><img src="'+s+'" alt="image.png"></p></li><li><p>步骤二：在请求派发数据时，用步骤一整合好的参数来请求。</p><p><img src="'+c+'" alt="image.png"></p></li><li><p>步骤三：至此，刷新网页后可以进行一次搜索并返回正确的商品列表。但我们发现，这样的搜索只能实现一次，因为数据只在挂载时请求过一次，我们希望用户每次在搜索框中进行搜索时都可以更新结果列表，所以要为搜索词（<code>this.$route</code>）添加监听事件。</p><p><img src="'+o+'" alt="image.png"></p></li></ul><h2 id="_2-面包屑功能" tabindex="-1">2. 面包屑功能 <a class="header-anchor" href="#_2-面包屑功能" aria-label="Permalink to &quot;2. 面包屑功能&quot;">​</a></h2><h3 id="_2-1-三级分类的面包屑" tabindex="-1">2.1 三级分类的面包屑 <a class="header-anchor" href="#_2-1-三级分类的面包屑" aria-label="Permalink to &quot;2.1 三级分类的面包屑&quot;">​</a></h3><ul><li><p>页面结构</p><p><img src="'+_+'" alt="image.png"></p></li><li><p>js 逻辑，如果把之前的置空改为 undefined，可以优化性能</p><p><img src="'+m+'" alt="image.png"></p></li></ul><h3 id="_2-2-搜索词的面包屑" tabindex="-1">2.2 搜索词的面包屑 <a class="header-anchor" href="#_2-2-搜索词的面包屑" aria-label="Permalink to &quot;2.2 搜索词的面包屑&quot;">​</a></h3><ul><li><p>页面结构</p><p><img src="'+n+'" alt="image.png"></p></li><li><p>js 逻辑</p><p><img src="'+h+'" alt="image.png"></p></li></ul><h3 id="_2-3-品牌的面包屑" tabindex="-1">2.3 品牌的面包屑 <a class="header-anchor" href="#_2-3-品牌的面包屑" aria-label="Permalink to &quot;2.3 品牌的面包屑&quot;">​</a></h3><ul><li><p>Search 组件的页面结构</p><p><img src="'+g+'" alt="image.png"></p><p>由于品牌的页面结构是写在 Search 的子组件 SearchSelector 中的，所以要在 SearchSelector 组件内设置点击事件，当用户点击某品牌，将品牌数据传给父组件 Search，然后再由父组件内触发品牌面包屑事件。</p></li><li><p>SearchSelector 组件的页面结构</p><p><img src="'+u+'" alt="image.png"></p></li><li><p>SearchSelector 组件的事件</p><p><img src="'+d+'" alt="image.png"></p></li><li><p>Search 组件中定义点击品牌面包屑的事件</p><ul><li><p>在页面结构中接收传值</p><p><img src="'+b+'" alt="image.png"></p></li></ul></li><li><p>书写事件</p><p><img src="'+S+'" alt="image.png"></p></li></ul><h3 id="_2-4-售卖属性面包屑" tabindex="-1">2.4 售卖属性面包屑 <a class="header-anchor" href="#_2-4-售卖属性面包屑" aria-label="Permalink to &quot;2.4 售卖属性面包屑&quot;">​</a></h3><ul><li><p>步骤一：售卖属性的页面结构是写在 Search 的子组件 SearchSelector 中的，所以当点击某个属性时，要进行子向父传值。在子组件中： <img src="'+f+'" alt="image.png"></p><p><img src="'+q+'" alt="image.png"></p></li><li><p>步骤二：在 Search 组件中接收子组件传来的属性信息，并整理参数存放到 searchParams 中，再重新请求数据，这样就实现了点击属性返回属性相关的商品信息。</p><ul><li><p>页面结构</p><p><img src="'+x+'" alt="image.png"></p></li><li><p>逻辑</p><p><img src="'+P+'" alt="image.png"></p></li></ul></li><li><p>步骤三：实现面包屑的取消功能。</p><ul><li>页面结构</li></ul><p><img src="'+k+'" alt="image.png"></p><ul><li>逻辑</li></ul><p><img src="'+T+'" alt="image.png"></p></li></ul>',15),$=[v];function V(A,N,B,C,D,E){return e(),i("div",null,$)}const O=a(j,[["render",V]]);export{J as __pageData,O as default};
