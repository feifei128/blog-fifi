import{_ as a,o as i,c as e,V as t}from"./chunks/framework.f3592640.js";const l="/blog-fifi/images/购物车1.png",o="/blog-fifi/images/购物车2.png",r="/blog-fifi/images/购物车3.png",n="/blog-fifi/images/购物车4.png",s="/blog-fifi/images/购物车5.png",p="/blog-fifi/images/购物车6.png",g="/blog-fifi/images/购物车7.png",c="/blog-fifi/images/购物车8.png",m="/blog-fifi/images/购物车9.png",h="/blog-fifi/images/购物车10.png",_="/blog-fifi/images/购物车11.png",d="/blog-fifi/images/购物车12.png",u="/blog-fifi/images/购物车13.png",f="/blog-fifi/images/购物车14.png",b="/blog-fifi/images/购物车15.png",q="/blog-fifi/images/购物车16.png",x="/blog-fifi/images/购物车17.png",P="/blog-fifi/images/购物车18.png",k="/blog-fifi/images/购物车19.png",v="/blog-fifi/images/购物车20.png",N=JSON.parse('{"title":"购物车","description":"","frontmatter":{},"headers":[],"relativePath":"projects/shangpinhui/08-购物车.md","filePath":"projects/shangpinhui/08-购物车.md"}'),T={name:"projects/shangpinhui/08-购物车.md"},j=t(`<h1 id="购物车" tabindex="-1">购物车 <a class="header-anchor" href="#购物车" aria-label="Permalink to &quot;购物车&quot;">​</a></h1><h2 id="_1-游客身份" tabindex="-1">1. 游客身份 <a class="header-anchor" href="#_1-游客身份" aria-label="Permalink to &quot;1. 游客身份&quot;">​</a></h2><h3 id="_1-1-用途" tabindex="-1">1.1 用途 <a class="header-anchor" href="#_1-1-用途" aria-label="Permalink to &quot;1.1 用途&quot;">​</a></h3><p>购物车的查看与结算等功能实现的前提，就是用户 ID，用户的身份有两种：游客和已登录，下面将记录游客身份是如何实现的。</p><h3 id="_1-2-npm-包" tabindex="-1">1.2 npm 包 <a class="header-anchor" href="#_1-2-npm-包" aria-label="Permalink to &quot;1.2 npm 包&quot;">​</a></h3><pre><code>1. uuid：教程所用 npm 包
2. nanoid：弹幕网友推荐的 npm 包
</code></pre><h3 id="_1-3-使用方法" tabindex="-1">1.3 使用方法 <a class="header-anchor" href="#_1-3-使用方法" aria-label="Permalink to &quot;1.3 使用方法&quot;">​</a></h3><ol><li>根据 npm 官网的使用教程，复制 import 代码</li></ol><p><img src="`+l+'" alt="image.png"></p><ol start="2"><li>在 src 下新建一个文件夹 utils 和文件 uuid_token.js。粘贴上一步复制的代码，书写自己的需求。</li></ol><p><img src="'+o+'" alt="image.png"></p><h2 id="_2-动态展示数据" tabindex="-1">2. 动态展示数据 <a class="header-anchor" href="#_2-动态展示数据" aria-label="Permalink to &quot;2. 动态展示数据&quot;">​</a></h2><h3 id="_2-1-基础数据渲染" tabindex="-1">2.1 基础数据渲染 <a class="header-anchor" href="#_2-1-基础数据渲染" aria-label="Permalink to &quot;2.1 基础数据渲染&quot;">​</a></h3><p>常规步骤（建立 api 接口，布置静态页面，搭建 vuex，渲染页面）。</p><p><img src="'+r+'" alt="image.png"></p><h3 id="_2-2-更改商品数量" tabindex="-1">2.2 更改商品数量 <a class="header-anchor" href="#_2-2-更改商品数量" aria-label="Permalink to &quot;2.2 更改商品数量&quot;">​</a></h3><h4 id="_2-2-1-思路" tabindex="-1">2.2.1 思路 <a class="header-anchor" href="#_2-2-1-思路" aria-label="Permalink to &quot;2.2.1 思路&quot;">​</a></h4><p>后台同事在书写加购功能时，已经定义好向 vuex 传参的商品数量为购物车中该商品的“变化量”（初始为 0，所以当第一次加购该商品时，变化量为 1，加购成功后就是 0+1=1），即加购为正数，移除购物车为负数。而商品数量的变化可以通过三个地方实现（加减号和文本框），将这三处绑定一个事件，算出变化量（加号变化量为 1，减号变化量为-1，文本框变化量为新 value-旧 value），再通过请求派发数据的函数传递变化量即可。</p><h4 id="_2-2-2-代码" tabindex="-1">2.2.2 代码： <a class="header-anchor" href="#_2-2-2-代码" aria-label="Permalink to &quot;2.2.2 代码：&quot;">​</a></h4><ul><li>页面结构</li></ul><p><img src="'+n+'" alt="image.png"></p><ul><li>逻辑</li></ul><p><img src="'+s+'" alt="image.png"></p><h4 id="_2-2-3-注意" tabindex="-1">2.2.3 注意 <a class="header-anchor" href="#_2-2-3-注意" aria-label="Permalink to &quot;2.2.3 注意&quot;">​</a></h4><p>在减号操作时，如果用户过快地点击减号，会出现负数的情况，正常点击速度是不会这样的，因为我们已经做了防负数处理。此时，需要进行节流，将上述代码进行改善：（改函数头部，添加节流时间）</p><p><img src="'+p+'" alt="image.png"></p><h3 id="_2-3-移除购物车" tabindex="-1">2.3 移除购物车 <a class="header-anchor" href="#_2-3-移除购物车" aria-label="Permalink to &quot;2.3 移除购物车&quot;">​</a></h3><ol><li>思路</li></ol><p>在接口文档中查看到的请求方式为 delete，是与之前所有的接口都不同的。实现思路与上一次加购成功页面的接口类似，所以不需要真实让后台返回什么数据，但我们得知道请求成功与否，就再 dispatch 一下即可，然后重新拉取数据。注意：在 vuex 的三段中，只写 actions 即可，但由于 eslint 限制，还是要将三段写完整。</p><ol start="2"><li><p>代码</p><ul><li>页面结构：黄色框内为删除功能，红色线为绑定删除事件。</li></ul><p><img src="'+g+'" alt="image.png"></p><ul><li>逻辑</li></ul><p><img src="'+c+'" alt="image.png"></p></li></ol><h3 id="_2-4-更改商品选中状态" tabindex="-1">2.4 更改商品选中状态 <a class="header-anchor" href="#_2-4-更改商品选中状态" aria-label="Permalink to &quot;2.4 更改商品选中状态&quot;">​</a></h3><h4 id="_2-4-1-思路" tabindex="-1">2.4.1 思路 <a class="header-anchor" href="#_2-4-1-思路" aria-label="Permalink to &quot;2.4.1 思路&quot;">​</a></h4><p>与移除购物车的实现思路一致，根据接口文档重新建立接口，然后 dispatch 一下即可。</p><h4 id="_2-4-2-代码" tabindex="-1">2.4.2 代码 <a class="header-anchor" href="#_2-4-2-代码" aria-label="Permalink to &quot;2.4.2 代码&quot;">​</a></h4><ul><li>页面结构：红线表示在渲染数据时复选框的初始状态，绿线表示绑定的点击事件。</li></ul><p><img src="'+m+'" alt="image.png"></p><ul><li>逻辑</li></ul><p><img src="'+h+'" alt="image.png"></p><h3 id="_2-5-将选中的商品批量移除购物车" tabindex="-1">2.5 将选中的商品批量移除购物车 <a class="header-anchor" href="#_2-5-将选中的商品批量移除购物车" aria-label="Permalink to &quot;2.5 将选中的商品批量移除购物车&quot;">​</a></h3><h4 id="_2-5-1-思路" tabindex="-1">2.5.1 思路 <a class="header-anchor" href="#_2-5-1-思路" aria-label="Permalink to &quot;2.5.1 思路&quot;">​</a></h4><p>查看接口文档，发现后台没有提供对此功能的专门接口，那么就不能按照上面三个功能的方式来实现该功能了。通过上面三次操作发现，我们是用 dispatch 向仓库中的 action 发请求，虽然我们没有接口了，但是可以在 action 下面自定义一个新函数，用来处理这个专门事件。</p><p><img src="'+_+'" alt="image.png"></p><p>context 为上下文参数，存储的是仓库的所有信息，上面三个函数中的{ commit }是对 context 的解构，观察 context 的内容我们发现，可以利用 getters.cartList.cartInfoList 来获取购物车列表，对其进行遍历，在遍历中调用 deleteCartList 函数就可以实现批量删除的操作了。</p><h4 id="_2-5-2-代码" tabindex="-1">2.5.2 代码： <a class="header-anchor" href="#_2-5-2-代码" aria-label="Permalink to &quot;2.5.2 代码：&quot;">​</a></h4><ul><li>页面结构</li></ul><p><img src="'+d+'" alt="image.png"></p><ul><li>逻辑</li></ul><p><img src="'+u+'" alt="image.png"></p><ul><li>仓库</li></ul><p><img src="'+f+'" alt="image.png"></p><p>仓库的函数写到这样就可以实现批量删除了，但是鲁棒性不好，成功的情况下没什么问题，若删除失败问题就大了，我们不知道删除几个失败还是全部失败，因此要进行改善：</p><p><img src="'+b+'" alt="image.png"></p><p>由于返回值为 promise 的结果，那么在 vue 文件中用 js 代码调用该函数时，也要加上 await 和 aysnc，并用 try 将原本的函数体包裹起来：</p><p><img src="'+q+'" alt="image.png"></p><h3 id="_2-6-全选业务" tabindex="-1">2.6 全选业务 <a class="header-anchor" href="#_2-6-全选业务" aria-label="Permalink to &quot;2.6 全选业务&quot;">​</a></h3><h4 id="_2-6-1-思路" tabindex="-1">2.6.1 思路 <a class="header-anchor" href="#_2-6-1-思路" aria-label="Permalink to &quot;2.6.1 思路&quot;">​</a></h4><p>全选按钮控制所有商品的选中状态和批量删除是一样的操作来实现。但是，每个商品的选中状态也要反过来决定全选按钮的选中状态，只有当所有商品都被选中时，全选按钮才被选中，其他情况均为非全选，是一个“与”问题。因此，在使用计算属性为全选按钮进行渲染时，可以比较已选中的商品数量是否等于商品总数量，是则为全选。</p><h4 id="_2-6-2-代码" tabindex="-1">2.6.2 代码 <a class="header-anchor" href="#_2-6-2-代码" aria-label="Permalink to &quot;2.6.2 代码&quot;">​</a></h4><ul><li>页面结构：其中黄线为渲染（每个商品的选中状态决定全选按钮的选中状态），紫线为点击事件（全选按钮的选中状态决定每个商品的选中状态）</li></ul><p><img src="'+x+'" alt="image.png"></p><ul><li><p>逻辑</p><ul><li>计算属性</li></ul><p><img src="'+P+'" alt="image.png"></p><ul><li>方法</li></ul><p><img src="'+k+'" alt="image.png"></p></li><li><p>仓库（注意：在 dispatch 时，多参数一定要用 { } 包起来，并且必须用 : 为参数赋值，不能只写实参量；在使用 promise 返回值时，必须用 await 和 aysnc，否则结果会出现延时或者混乱的情况）</p><p><img src="'+v+'" alt="image.png"></p></li></ul>',61),S=[j];function I(V,$,y,A,C,D){return i(),e("div",null,S)}const w=a(T,[["render",I]]);export{N as __pageData,w as default};
