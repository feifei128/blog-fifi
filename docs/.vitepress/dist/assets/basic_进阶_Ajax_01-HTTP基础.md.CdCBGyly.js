import{_ as a,c as s,o as e,a4 as n,aU as t,aV as l}from"./chunks/framework.C8gDNRqg.js";const b=JSON.parse('{"title":"HTTP","description":"","frontmatter":{},"headers":[],"relativePath":"basic/进阶/Ajax/01-HTTP基础.md","filePath":"basic/进阶/Ajax/01-HTTP基础.md"}'),p={name:"basic/进阶/Ajax/01-HTTP基础.md"},i=n(`<h1 id="http" tabindex="-1">HTTP <a class="header-anchor" href="#http" aria-label="Permalink to &quot;HTTP&quot;">​</a></h1><blockquote><p>HTTP（hypertext transport protocol）协议『超文本传输协议』，协议详细规定了浏览器和万维网服务器之间互相通信的规则。</p></blockquote><p>HTTP请求交互的过程是什么样的呢？</p><ol><li>前后应用从浏览器端向服务器发送HTTP 请求(请求报文)</li><li>后台服务器接收到请求后, 调度服务器应用处理请求, 向浏览器端返回HTTP响应(响应报文)</li><li>浏览器端接收到响应, 解析显示响应体/调用监视回调</li></ol><h2 id="http-报文" tabindex="-1">HTTP 报文 <a class="header-anchor" href="#http-报文" aria-label="Permalink to &quot;HTTP 报文&quot;">​</a></h2><h3 id="请求报文" tabindex="-1">请求报文 <a class="header-anchor" href="#请求报文" aria-label="Permalink to &quot;请求报文&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>行      POST  /s?ie=utf-8  HTTP/1 </span></span>
<span class="line"><span>头      Host: www.baidu.com</span></span>
<span class="line"><span>        Cookie: BAIDUID=AD3B0FA706E; BIDUPSID=AD3B0FA706;    </span></span>
<span class="line"><span>        Content-type: application/x-www-form-urlencoded</span></span>
<span class="line"><span>        User-Agent: chrome 83</span></span>
<span class="line"><span>空行</span></span>
<span class="line"><span>体      username=admin&amp;password=admin</span></span></code></pre></div><h3 id="响应报文" tabindex="-1">响应报文 <a class="header-anchor" href="#响应报文" aria-label="Permalink to &quot;响应报文&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>行      HTTP/1  200  OK</span></span>
<span class="line"><span>头      Content-Type: text/html;charset=utf-8</span></span>
<span class="line"><span>       Set-Cookie: BD_CK_SAM=1;path=/</span></span>
<span class="line"><span>        Content-length: 2048</span></span>
<span class="line"><span>        Content-encoding: gzip</span></span>
<span class="line"><span>空行    </span></span>
<span class="line"><span>体      &lt;html&gt;</span></span>
<span class="line"><span>            &lt;head&gt;</span></span>
<span class="line"><span>            &lt;/head&gt;</span></span>
<span class="line"><span>            &lt;body&gt;</span></span>
<span class="line"><span>                &lt;h1&gt;尚硅谷&lt;/h1&gt;</span></span>
<span class="line"><span>            &lt;/body&gt;</span></span>
<span class="line"><span>        &lt;/html&gt;</span></span>
<span class="line"><span>        (html 文本/json 文本/js/css/图片...)</span></span></code></pre></div><h3 id="chrome浏览器查看通信报文" tabindex="-1">Chrome浏览器查看通信报文 <a class="header-anchor" href="#chrome浏览器查看通信报文" aria-label="Permalink to &quot;Chrome浏览器查看通信报文&quot;">​</a></h3><p><img src="`+t+'" alt=""></p><h2 id="http-多版本" tabindex="-1">HTTP 多版本 <a class="header-anchor" href="#http-多版本" aria-label="Permalink to &quot;HTTP 多版本&quot;">​</a></h2><h3 id="http-1-1-协议" tabindex="-1"><code>HTTP/1.1</code> 协议 <a class="header-anchor" href="#http-1-1-协议" aria-label="Permalink to &quot;`HTTP/1.1` 协议&quot;">​</a></h3><p>HTTP/1.1 默认使用了持久连接，多个请求可以复用同一个 TCP 连接，但是在同一个 TCP 连接里面，数据请求的通信次序是固定的。服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，如果前面请求的响应特别慢的话，就会造成许多请求排队等待的情况，这种情况被称为“队头堵塞”。队头阻塞会导致持久连接在达到最大数量时，剩余的资源需要等待其他 资源请求完成后才能发起请求。</p><p>为了避免这个问题，一个是减少请求数，一个是同时打开多个持久连接。这就是我们对网站优化时，使用雪碧图、合并脚本的原因。</p><h3 id="http-2-协议" tabindex="-1"><code>HTTP/2</code> 协议 <a class="header-anchor" href="#http-2-协议" aria-label="Permalink to &quot;`HTTP/2` 协议&quot;">​</a></h3><p>2009 年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。这个协议在 Chrome 浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。2015 年，HTTP/2 发布。</p><p>HTTP/2 主要有以下新的特性：</p><h4 id="_1-二进制协议" tabindex="-1">1. 二进制协议 <a class="header-anchor" href="#_1-二进制协议" aria-label="Permalink to &quot;1. 二进制协议&quot;">​</a></h4><p>HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为&quot;帧&quot;，可以分为头信息帧和数据帧。帧的概念是它实现多路复用的基础。</p><h4 id="_2-多路复用" tabindex="-1">2. 多路复用 <a class="header-anchor" href="#_2-多路复用" aria-label="Permalink to &quot;2. 多路复用&quot;">​</a></h4><p>HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了&quot;队头堵塞&quot;的问题。</p><h4 id="_3-数据流" tabindex="-1">3. 数据流 <a class="header-anchor" href="#_3-数据流" aria-label="Permalink to &quot;3. 数据流&quot;">​</a></h4><p>HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流。</p><h4 id="_4-头信息压缩" tabindex="-1">4. 头信息压缩 <a class="header-anchor" href="#_4-头信息压缩" aria-label="Permalink to &quot;4. 头信息压缩&quot;">​</a></h4><p>HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p><p>HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</p><h4 id="_5-服务器推送" tabindex="-1">5. 服务器推送 <a class="header-anchor" href="#_5-服务器推送" aria-label="Permalink to &quot;5. 服务器推送&quot;">​</a></h4><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送，提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</p><p><strong>HTTP/2 协议缺点</strong>：</p><p>因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。由于多个数据流使用同一个 TCP 连接，遵守同一个流量状态控制和拥塞控制。只要一个数据流遭遇到拥塞，剩下的数据流就没法发出去，这样就导致了后面的所有数据都会被阻塞。HTTP/2 出现的这个问题是由于其使用 TCP 协议的问题，与它本身的实现其实并没有多大关系。</p><h3 id="http-3-协议" tabindex="-1"><code>HTTP/3</code> 协议 <a class="header-anchor" href="#http-3-协议" aria-label="Permalink to &quot;`HTTP/3` 协议&quot;">​</a></h3><p>由于 TCP 本身存在的一些限制，Google 就开发了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上。 QUIC 协议在 UDP 协议上实现了多路复用、有序交付、重传等等功能。</p><h3 id="https-协议" tabindex="-1"><code>HTTPS</code> 协议 <a class="header-anchor" href="#https-协议" aria-label="Permalink to &quot;`HTTPS` 协议&quot;">​</a></h3><h4 id="http-存在的问题" tabindex="-1">HTTP 存在的问题 <a class="header-anchor" href="#http-存在的问题" aria-label="Permalink to &quot;HTTP 存在的问题&quot;">​</a></h4><ol><li>HTTP 报文使用明文方式发送，可能被第三方窃听。</li><li>HTTP 报文可能被第三方截取后修改通信内容，接收方没有办法发现报文内容的修改。</li><li>HTTP 还存在认证的问题，第三方可以冒充他人参与通信。</li></ol><h4 id="https-简介" tabindex="-1">HTTPS 简介 <a class="header-anchor" href="#https-简介" aria-label="Permalink to &quot;HTTPS 简介&quot;">​</a></h4><p>HTTPS 指的是超文本传输安全协议，HTTPS 是基于 HTTP 协议的，不过它会使用 TLS/SSL 来对数据加密。使用 TLS/SSL 协议，所有的信息都是加密的，第三方没有办法窃听。并且它提供了一种校验机制，信息一旦被篡改，通信的双方会立刻发现。它还配备了身份证书，防止身份被冒充的情况出现。</p><h4 id="https-实现原理" tabindex="-1">HTTPS 实现原理 <a class="header-anchor" href="#https-实现原理" aria-label="Permalink to &quot;HTTPS 实现原理&quot;">​</a></h4><p><img src="'+l+'" alt=""></p><ol><li>服务器本身有一个公钥和一个私钥，公钥用来加密，私钥用来解密。</li><li>客户端向服务器发送一套加密方法和第一随机数。</li><li>服务器确认加密方法和第一随机数，生成第二随机数，发给向客户端并颁发证书和公钥。</li><li>客户端收到第二随机数和证书公钥，生成第三随机数，又叫做预主密钥，用刚刚收到的公钥对其进行加密后发给服务器。</li><li>服务器收到加密的预主密钥，用私钥对其进行解密。</li><li>双方此时可以同时用自身拥有的第一随机数 + 第二随机数 + 预主密钥 获得会话密钥。至此，非对称加密算法就是为了获得这个会话密钥。</li><li>此后的所有通信都将使用这个会话密钥进行对称加密。</li></ol>',41),o=[i];function h(r,T,c,d,P,u){return e(),s("div",null,o)}const m=a(p,[["render",h]]);export{b as __pageData,m as default};
