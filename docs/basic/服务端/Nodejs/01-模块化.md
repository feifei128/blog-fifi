# 模块化

## 含义

把一个大文件拆分成独立又互相依赖的小模块。

## 模块分类

- ⅰ. 内置模块：如 `fs`、`path`、`http` 等。（详述于下一节笔记。）
- ⅱ. 自定义模块：用户创建的每个 js 文件都算是。（加载模块的同时会执行）
- ⅲ. 第三方模块：需要提前下载的。

## 加载模块

使用 require()方法：

```
// 1．加载内置的fs模块
const fs = require('fs')
// 2. 加载用户的自定义模块
const custom=require('./custom.js')
// 3. 加载第三方模块
const moment = require('moment')
```

## 模块作用域

- ⅰ. 含义：在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问。
- ⅱ. `module` 对象：存储了和当前模块有关的信息。 \*`module.exports` 对象：将模块内的成员共享出去。`require()` 导入自定义磨块时，得到的就是 `module.exports` 所指向 的对象。
- ⅲ. `exports` 对象：默认情况下和 `module.exports` 指向同一个对象，最终共享的结果还是以 `module.export` 指向的对象为准。

## 模块化规范 -- CommonJS

CommonJS 规定：

- 每个模块内部，`module` 变量代表当前模块。
- module 变量是一个对象，它的 `exports` 属性(即 `module.exports`)是对外的接口。
- 加载某个模块，其实是加载该模块的 `module.exports` 属性。`require()` 方法用于加载模块。

## 模块的加载机制

- 优先从缓存中加载
- 内置模块的加载机制：若有第三方模块与内置模块同名，优先加载内置模块。
- 自定义模块的加载机制
  - ⅰ. 必须添加路径标识符，不然 node 会将它当作其他类型模块。
  - ⅱ. 若省略了文件扩展名，node 会自动分别尝试 `.js`、`.json`、`.node`。
- 第三方模块的加载机制：如果不是内置模块或自定义模块，nodejs 会从当前模块的父目录开始（这一层的没找到就继续退一层目录继续找，直至退到磁盘根目录），尝试冲 node_modules 文件夹中加载第三方模块。
- 目录作为模块：当把目录作为模块标识符，传递给 `require()`进行加载的时候，有三种加载方式:
  - 在被加载的目录下查找一个叫做 package.json 的文件，并寻找 main 属性，作为 `require()` 加载的入口
  - 如果目录里没有 package.json 文件，或者 main 入口不存在或无法解析，则 Nodejs 将会试图加载目录下的 `index.js` 文件。
  - 如果以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺失: `Error: Cannot find module 'xxx'`
