# 购物车

## 1. 游客身份

### 1.1 用途

购物车的查看与结算等功能实现的前提，就是用户 ID，用户的身份有两种：游客和已登录，下面将记录游客身份是如何实现的。

### 1.2 npm 包

    1. uuid：教程所用 npm 包
    2. nanoid：弹幕网友推荐的 npm 包

### 1.3 使用方法

1. 根据 npm 官网的使用教程，复制 import 代码

![image.png](/images/购物车1.png)

2. 在 src 下新建一个文件夹 utils 和文件 uuid_token.js。粘贴上一步复制的代码，书写自己的需求。

![image.png](/images/购物车2.png)

## 2. 动态展示数据

### 2.1 基础数据渲染

常规步骤（建立 api 接口，布置静态页面，搭建 vuex，渲染页面）。

![image.png](/images/购物车3.png)

### 2.2 更改商品数量

#### 2.2.1 思路

后台同事在书写加购功能时，已经定义好向 vuex 传参的商品数量为购物车中该商品的“变化量”（初始为 0，所以当第一次加购该商品时，变化量为 1，加购成功后就是 0+1=1），即加购为正数，移除购物车为负数。而商品数量的变化可以通过三个地方实现（加减号和文本框），将这三处绑定一个事件，算出变化量（加号变化量为 1，减号变化量为-1，文本框变化量为新 value-旧 value），再通过请求派发数据的函数传递变化量即可。

#### 2.2.2 代码：

- 页面结构

![image.png](/images/购物车4.png)

- 逻辑

![image.png](/images/购物车5.png)

#### 2.2.3 注意

在减号操作时，如果用户过快地点击减号，会出现负数的情况，正常点击速度是不会这样的，因为我们已经做了防负数处理。此时，需要进行节流，将上述代码进行改善：（改函数头部，添加节流时间）

![image.png](/images/购物车6.png)

### 2.3 移除购物车

1. 思路

在接口文档中查看到的请求方式为 delete，是与之前所有的接口都不同的。实现思路与上一次加购成功页面的接口类似，所以不需要真实让后台返回什么数据，但我们得知道请求成功与否，就再 dispatch 一下即可，然后重新拉取数据。注意：在 vuex 的三段中，只写 actions 即可，但由于 eslint 限制，还是要将三段写完整。

2. 代码

   - 页面结构：黄色框内为删除功能，红色线为绑定删除事件。

   ![image.png](/images/购物车7.png)

   - 逻辑

   ![image.png](/images/购物车8.png)

### 2.4 更改商品选中状态

#### 2.4.1 思路

与移除购物车的实现思路一致，根据接口文档重新建立接口，然后 dispatch 一下即可。

#### 2.4.2 代码

- 页面结构：红线表示在渲染数据时复选框的初始状态，绿线表示绑定的点击事件。

![image.png](/images/购物车9.png)

- 逻辑

![image.png](/images/购物车10.png)

### 2.5 将选中的商品批量移除购物车

#### 2.5.1 思路

查看接口文档，发现后台没有提供对此功能的专门接口，那么就不能按照上面三个功能的方式来实现该功能了。通过上面三次操作发现，我们是用 dispatch 向仓库中的 action 发请求，虽然我们没有接口了，但是可以在 action 下面自定义一个新函数，用来处理这个专门事件。

![image.png](/images/购物车11.png)

context 为上下文参数，存储的是仓库的所有信息，上面三个函数中的{ commit }是对 context 的解构，观察 context 的内容我们发现，可以利用 getters.cartList.cartInfoList 来获取购物车列表，对其进行遍历，在遍历中调用 deleteCartList 函数就可以实现批量删除的操作了。

#### 2.5.2 代码：

- 页面结构

![image.png](/images/购物车12.png)

- 逻辑

![image.png](/images/购物车13.png)

- 仓库

![image.png](/images/购物车14.png)

仓库的函数写到这样就可以实现批量删除了，但是鲁棒性不好，成功的情况下没什么问题，若删除失败问题就大了，我们不知道删除几个失败还是全部失败，因此要进行改善：

![image.png](/images/购物车15.png)

由于返回值为 promise 的结果，那么在 vue 文件中用 js 代码调用该函数时，也要加上 await 和 aysnc，并用 try 将原本的函数体包裹起来：

![image.png](/images/购物车16.png)

### 2.6 全选业务

#### 2.6.1 思路

全选按钮控制所有商品的选中状态和批量删除是一样的操作来实现。但是，每个商品的选中状态也要反过来决定全选按钮的选中状态，只有当所有商品都被选中时，全选按钮才被选中，其他情况均为非全选，是一个“与”问题。因此，在使用计算属性为全选按钮进行渲染时，可以比较已选中的商品数量是否等于商品总数量，是则为全选。

#### 2.6.2 代码

- 页面结构：其中黄线为渲染（每个商品的选中状态决定全选按钮的选中状态），紫线为点击事件（全选按钮的选中状态决定每个商品的选中状态）

![image.png](/images/购物车17.png)

- 逻辑

  - 计算属性

  ![image.png](/images/购物车18.png)

  - 方法

  ![image.png](/images/购物车19.png)

- 仓库（注意：在 dispatch 时，多参数一定要用 { } 包起来，并且必须用 : 为参数赋值，不能只写实参量；在使用 promise 返回值时，必须用 await 和 aysnc，否则结果会出现延时或者混乱的情况）

  ![image.png](/images/购物车20.png)
